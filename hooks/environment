#!/bin/bash
set -eu -o pipefail

basedir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && cd .. && pwd )"

# shellcheck disable=SC1090
. "$basedir/lib/shared.bash"

export TMPDIR=${TMPDIR:-/tmp}
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-us-east-1}
readonly prefix="${BUILDKITE_SECRETS_MANAGER_PREFIX:-elastic-ci-stack}"

debug() {
  if [[ "${BUILDKITE_SECRETS_MANAGER_DEBUG:-false}" =~ (true|on|1) ]] ; then
    echo "$@"
  fi
}

echo "~~~ Downloading secrets from AWS Secrets Manager" >&2;
debug "Searching in prefix ${prefix} in region ${AWS_DEFAULT_REGION}"

# Read all the secret keys into an array
secrets=()
while read -r name _ ; do
  secrets+=("$name")
done < <(sm_secret_names)

# First up we look for ssh keys if the repository is ssh
if [[ "${BUILDKITE_REPO:-}" =~ ^git ]] ; then
  ssh_key_paths=(
    "global/ssh-private-key"
    "pipeline/${BUILDKITE_PIPELINE_SLUG}/ssh-private-key"
  )

  # Look in our key paths in order, but we'll load them all
  for key in ${ssh_key_paths[*]} ; do
    full_key="${prefix}/${key}"
    debug "Checking ${full_key}" >&2

    # Check if that secret key exists
    if in_array "$full_key" "${secrets[@]}" ; then
      echo "Found ssh-key at ${full_key}" >&2;

      if ! ssh_key=$(sm_secret_get "$full_key") ; then
        echo "+++ :warning: Failed to get secret for ssh-key $full_key" >&2;
        exit 1
      fi

      # Add the ssh key to an ephemeral ssh agent so the key never touches disk
      debug "Got ${#ssh_key} bytes of ssh key"
      add_ssh_private_key_to_agent "$ssh_key"
      key_found=1
    fi
  done

  if [[ -z "${key_found:-}" ]] ; then
    echo "+++ :warning: Failed to find any ssh key secrets" >&2;
    exit 1
  fi
fi

# Otherwise check for git credentials for https, use the first one we find
if [[ "${BUILDKITE_REPO:-}" =~ ^https ]] ; then
  git_credentials_paths=(
    "global/git-credentials"
    "pipeline/${BUILDKITE_PIPELINE_SLUG}/git-credentials"
  )

  git_credentials=()

  for key in ${git_credentials_paths[*]} ; do
    full_key="${prefix}/${key}"
    debug "Checking ${full_key}" >&2

    if in_array "$full_key" "${secrets[@]}" ; then
      echo "Adding git-credentials in $full_key as a credential helper" >&2;
      git_credentials+=("'credential.helper=$basedir/git-credential-sm-secrets ${full_key}'")
    fi
  done

  if [[ "${#git_credentials[@]}" -gt 0 ]] ; then
    export GIT_CONFIG_PARAMETERS
    debug "Setting GIT_CONFIG_PARAMETERS"
    GIT_CONFIG_PARAMETERS=$( IFS=' '; echo -n "${git_credentials[*]}" )
  fi
fi

# env_paths=(
#   "env"
#   "environment"
#   "${s3_bucket_prefix}/env"
#   "${s3_bucket_prefix}/environment"
# )

# env_before="$(env | sort)"

# for key in ${env_paths[*]} ; do
#   if s3_exists "$s3_bucket" "$key" ; then
#     echo "Downloading env file from ${key}" >&2;
#     if ! envscript=$(s3_download "${s3_bucket}" "$key") ; then
#       echo "+++ :warning: Failed to download env from $key" >&2;
#       exit 1
#     fi
#     echo "Evaluating ${#envscript} bytes of env"
#     set -o allexport
#     eval "$envscript"
#     set +o allexport
#   fi
# done

# git_credentials_paths=(
#   "git-credentials"
#   "${s3_bucket_prefix}/git-credentials"
# )

# git_credentials=()

# for key in ${git_credentials_paths[*]} ; do
#   if s3_exists "$s3_bucket" "$key" ; then
#     echo "Adding git-credentials in $key as a credential helper" >&2;
#     git_credentials+=("'credential.helper=$basedir/git-credential-sm-secrets ${s3_bucket} ${key}'")
#   fi
# done

# if [[ "${#git_credentials[@]}" -gt 0 ]] ; then
#   export GIT_CONFIG_PARAMETERS
#   GIT_CONFIG_PARAMETERS=$( IFS=' '; echo -n "${git_credentials[*]}" )
# fi

